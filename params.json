{"name":"Offline Concurrency Patterns","tagline":"Projeto que exemplifica alguns padrões de projeto sobre Concorrência Offline.","body":"# Introdução\r\nOi, eu sou o Renan. Hoje falarei sobre quatro padrões encontrados no livro Patterns of Enterprise Application, de Martin Fowler. Os padrões podem se encontrados no capítulo 16, Offline Concurrency Patterns, escritos por David Rice e Matt Foemmel. Os padrões descritos à seguir serão: Optimistic Offline Lock, Pessimistic Offline Lock, Coarse-Grained Lock e Implicit Lock. Sem mais delongas, vamos começar.  \r\n\r\n# Optimistic Offline Lock\r\nEsse padrão tem esse nome pois ele assume que as chances de conflito entre transações serão baixas.  \r\n\r\n### Qual o problema?\r\nQuando duas transações manipulam um mesmo dado, a integridade do mesmo pode ser comprometida. Isso ocorre pois não há garantia que o SGBD de fato manterá os dados consistentes ao término da transação. Para exemplicar essa situação, vamos analisar a Figura 1:  \r\n\r\n![Lost Update](https://drive.google.com/open?id=0B-o9prCsV_v8ZktIdHNHU1VWN0U)\r\nFigura 1 - Lost Update  \r\n\r\nNa Figura 1 vemos que, mesmo que cada transação isolada fosse mantida pelo SGBD, o updateDado12() realizado no passo 3 seria perdido quando o passo 4 fosse realizado. Isso tornaria o estado do banco inconsistente.  \r\n\r\n### Como funciona?\r\nPara resolver esse problema, o Optimistic Offline Concurrency seguindo algumas abordagens:\r\n* Uma opção seria adicionar uma nova coluna em cada tabela contendo a versão atual do registro do registro. A versão pode ser tão simples como um número que vai incrementado à medida que o registro vai sofrendo alterações. Um complemento interessante para o campo de versão seria adicionar também campos de data e responsável pela ultima modificação, facilitando o trabalho de identificação do autor da modificação e consequentemente a resolução do conflito.\r\n* Uma outra abordagem seria verificar campo a campo todos os valores das colunas do registro e ver se algum valor sofreu modificação desde a ultima vez que o dado foi acessado.\r\nIndependente da forma que o padrão seja implementado, a ideia é a mesma: as alterações realizadas no registro só poderão ser de fato efetuadas no banco (commit) se o registro não tiver sido modificado nesse meio tempo. A Figura 2 mostra como o padrão funciona.  \r\n\r\n![Optimistic Offline Lock](https://goo.gl/tJOEsF)\r\nFigura 2 - Optimistic Offline Lock  \r\n\r\nVemos então na Figura 2, mais precisamente na etapa 4.1, que o update realizado na etapa 4 não foi efetuado, pois na etapa 3 já havia sido feita uma operação de modificação no registro. Com isso o número da versão do mesmo foi alterado, e o usuário da Sessão 1 ficou impossibilitado de realizar a modificação.  \r\n\r\n### Cadê meu código?\r\nO código abaixo mostra um método encontrado em um DAO de Client que atualiza um registro somente se a versão não tiver sido alterada anteriormente.\r\n\r\n    public int optimisticUpdate(Client client) throws Exception {\r\n        open();\r\n        int registrosAfetados;\r\n        int versao = client.getVersao();\r\n        client.incrementarVersao();\r\n\r\n        stmt = con.prepareStatement(\"UPDATE cliente SET nome = ?, sexo = ?, email = ?, versao = ? WHERE id = ? AND versao = ?\");\r\n        stmt.setString(1, client.getNome());\r\n        stmt.setString(2, client.getSexo());\r\n        stmt.setString(3, client.getEmail());\r\n        stmt.setInt(4, client.getVersao());\r\n        stmt.setInt(5, client.getId());\r\n        stmt.setInt(6, versao);\r\n\r\n        registrosAfetados = stmt.executeUpdate();\r\n        close();\r\n        return registrosAfetados;\r\n    }\r\n\r\n\r\n# Pessimistic Offline Lock\r\nEsse padrão força a transação à adquirir o lock sobre um dado antes de começar a usá-lo, impedindo assim que trabalhos realizados sobre um registro sejam perdidos.  \r\n\r\n### Qual o problema?\r\nEsse padrão é um complemento para o Optimistic Offline Lock. No Optimistic, há um conveniente muito grave. Todo o trabalho realizado na transação pode ser perdido caso alguma outra alteração tenha sido realizada no registro anteriormente. O Pessimistic tenta acabar com isso forçando a transação a obter o lock antes mesmo de manipular os dados.  \r\n\r\n### Como Funciona?\r\nA principal forma de implementação desse padrão é através da construção de um Gerenciador de Locks do Sistema. Nele estão contidos todos os locks concedidos, assim como métodos para obtenção e liberação de locks. O Gerenciador precisa ser regido por um conjunto de regras que irão definir o que fazer quando o lock não puder ser concedido, quando liberar ou conceder locks, etc. É preciso também definir quais tipos de locks serão utilizados. Normalmente, há três tipos de lock:\r\n* Lock Exclusivo de Leitura - Qualquer tentativa de acessar um dado para leitura deverá ter permissão através de um lock.\r\n* Lock Exclusivo de Escrita - Impossibilita a edição simultânea de um mesmo registro por duas transações, ignorando locks de leitura. Contudo, sessões de leitura podem ser desatualizados.\r\n* Lock de Leitura e Escrita - Locks de leitura e escrita são mutuamente exclusivos, mas locks de leitura podem ter acesso concorrente. Esse lock é o mais completo, permitindo maior grau de concorrência, no entanto, é mais complicado de ser implementado.  \r\n\r\n### Cadê meu código?\r\nO código abaixo mostra a implementação do DAO de Client utilzando a abordagem de Lock de Leitura e Escrita.\r\n\r\n\r\n    public Client pessimisticRead(int idCliente, String requester) throws Exception {\r\n        LockManager lockManager = LockManager.getInstance();\r\n        if (lockManager.acquireReadingLock(idCliente, requester)) {\r\n            Client cliente = get(idCliente);\r\n            return cliente;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    public int pessimisticWrite(Client cliente, String requester) throws Exception {\r\n        LockManager lockManager = LockManager.getInstance();\r\n        if (lockManager.acquireWritingLock(cliente.getId(), requester)) {\r\n            int rowsAffected = update(cliente);\r\n            return rowsAffected;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\nJá o código abaixo mostra a implementação do Gerenciador de Lock.\r\n\r\n\r\n    public class LockManager {\r\n\r\n    private static LockManager lockManager = null;\r\n\r\n    /*O Integer corresponde ao identificador do recurso\r\n     A String corresponde ao identificador do requisitante*/\r\n    private final Map<Integer, String> readingLockTable = new HashMap<>();\r\n    private final Map<Integer, String> writingLockTable = new HashMap<>();\r\n    private final Map<String, Integer[]> coarseGrainedLockTable = new HashMap<>();\r\n\r\n    private LockManager() {\r\n    }\r\n\r\n    /**\r\n     * Busca a única instância do LockManager\r\n     *\r\n     * @return o LockManager\r\n     */\r\n    public static LockManager getInstance() {\r\n        if (lockManager == null) {\r\n            lockManager = new LockManager();\r\n        }\r\n        return lockManager;\r\n    }\r\n\r\n     public boolean acquireReadingLock(Integer idResource, String requester) {\r\n        if (writingLockTable.get(idResource) == null) {\r\n            readingLockTable.put(idResource, requester);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n     public boolean acquireWritingLock(Integer idResource, String requester) {\r\n        if (writingLockTable.get(idResource) == null && readingLockTable.get(idResource) == null) {\r\n            writingLockTable.put(idResource, requester);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n# Coarse-Grained Lock\r\nO Coarse-Grained Lock trava um conjunto de objetos relacionados com apenas um lock.  \r\n\r\n### Qual o problema?\r\nCriar um lock separado para cada objeto pode ser complicado: é preciso achar os objetos na ordem certa, podendo ocasionar impacto no desempenho, principalmente no Optimistic Offline Lock. Além disso, o grau de complexidade aumenta com a quantidade de relações entre os objetos. Por fim, o sistema pode não se comportar como se espera quando o controle de locks fica sob responsabilidade de algum framework.  \r\n\r\n### Como funciona?\r\nPara resolver essa questão, é necessário criar um único ponto de acesso para o conjunto de objetos, de modo que apenas um lock seja necessário para acessá-los. Além disso, é preciso fornecer um método fácil para encontrar o único ponto de acesso para realizar o lock. Uma forma de implemtnação é através de um lock compartilhado, conforme Figura abaixo.\r\n\r\n![Shared Lock](https://drive.google.com/open?id=0B-o9prCsV_v8aWFTODRyd2sxTDQ)\r\nFigura 3 - Shared Lock\r\n\r\nUtilizando o lock compartilhado acima, é possível implementar facilmente o Pessimistic Lock, conforma Figura abaixo:\r\n\r\n![Pessimistic Shared Lock](https://drive.google.com/open?id=0B-o9prCsV_v8TWV6QWhSMFQ1WGM)\r\nFigura 4 - Pessimistic Shared Lock\r\n\r\n### Cadê meu código?\r\n\r\n    public List<Client> coarseGrainedRead(Integer[] idResources, String requester) throws Exception {\r\n\r\n        LockManager lockManager = LockManager.getInstance();\r\n        List<Client> clients;\r\n\r\n        if (lockManager.acquireCoarseGrainedLock(idResources, requester)) {\r\n            clients = new ArrayList<>();\r\n\r\n            for (Integer id : idResources) {\r\n                clients.add(get(id));\r\n            }\r\n\r\n            return clients;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n# Implicit Lock\r\nRetira o pesoa da utilização dos locks dos ombros do desenvolvedor.  \r\n\r\n### Qual o problema?\r\nTexto explicativo...\r\nDesenvolvedores estão propensos a erros, podendo esquecer de escrever uma única linha de código que adquire o lock, ou ainda não usar o contador de versão corretamente. Isso pode inviabilizar completamente a transação do sistema.  \r\n\r\n### Como Funciona?\r\nTarefas de lock não devem ser tratadas explicitamente pelos desenvolvedores, mas implicitamente pela aplicação. É possível terceirizar essa responsabilidades para Frameworks, o padrão Layers Supertypes, ou ainda Ferramentas de geração de código. É aconselhado usar esse padrão em todas as aplicações, exceto nas mais simples, uma vez que o risco de um haver pelos menos um lock esquecido é muito grande.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}